from tkinter.messagebox import *import threadingfrom Libs.GuiLib.gui_helpers import *from Libs.GuiLib.gui_styles import *from Libs.OSLib.chromedriver_helper import *from Libs.DataLib.json_helper import *from App_3500ParkingLogin.register_2_park import *from Libs.OSLib.os_helper import *import timefrom datetime import datetimefrom datetime import timedeltaimport logging# SET UP APP DATAapp_data = StandardAppDirStruct(os.getcwd(), "3500ParkingLogin")PATH_DATA = app_data.data_dir# SET UP LOGGERlog_main = "{}\\{}.log".format(app_data.logs_dir, app_data.app_name)logging.basicConfig(filename=log_main, level=logging.DEBUG)# PATH TO CHROMEDRIVERPATH_CHROMEDRIVER = '{}\\chromedriver'.format(PATH_DATA)dir_create(PATH_CHROMEDRIVER)JSON_CONFIG = '{}\\apt_config.json'.format(PATH_DATA)# CONFIG DATA KEYSRESIDENT_KEY = 'resident'APT_NUM_KEY = 'apt_num'DEF_EMAIL_KEY = 'default_email'JSON_USERS = '{}\\users.json'.format(PATH_DATA)# USER KEYSclass RegisterDictKeys:    MAKE = 'make'    MODEL = 'model'    LICENSE = 'license'    EMAIL = 'email'reg_keys = RegisterDictKeys()USER_NAME_KEY = 'name'# USER_MAKE_KEY = 'make'# USER_MODEL_KEY = 'model'# USER_LICENSE_KEY = 'license'# USER_EMAIL_KEY = 'email'# GUI USER INDICESUSER_ROW_INDEX = 0NAME_BTN_INDEX = 1DELETE_BTN_INDEX = 2class ParkingSession:    USER_DICT = 'user_dict'    DURATION = 'duration'    FIRST = 'first'    NEXT = 'next'    START_COUNT = 'start_count'    LEFT = 'left'    TIME_UNTIL = 'time_until'    def __init__(self, session_dict):        # todo finish this counter        returnclass NewParkingSession(dict):    # class SessionKeys:    #     REG_DICT = 'reg_dict'    #     START_TIME = 'start_time'    #     NEXT_TIME = 'next_time'    #     COUNT = 'count'    #     FREQUENCY = 'frequency'    #    # keys = SessionKeys()    def __init__(self, name, reg_dict, start_time, frequency, start_count, one_time=True):        super().__init__()        # SESSION DATA        self.name = name        self.reg_dict = reg_dict        self.start_time = start_time        self.next_time = self.start_time  # START AS START TIME        self.frequency = frequency        self.start_count = start_count        self.count_remaining = self.start_count        # ONE TIME FLAG - DETERMINES IF THIS WILL CREATE A SESSION OR NOT        self.one_time = one_time        # STOP SESSION FLAG        self.stop_session = False        # SET INITIAL NEXT TIME IMMEDIATELY        self.set_next_time()    def set_next_time(self):        self.next_time = self.next_time + self.frequency# reg_dict = {'name': 'Natalie', 'make': 'Volkswagen', 'model': 'Jetta', 'license': 'MJH3932', 'email': 'caseyray.lewis@gmail.com'}# new_session = NewParkingSession(reg_dict, datetime.now(), 4, timedelta(seconds=30))class RegisterFrame(Frame):    register_frequency = timedelta(seconds=10)    register_frequency_text = "10 seconds"    def __init__(self, root, config_data_dict, on_new_session_func=None, *args, **kwargs):        super().__init__(root, *args, **kwargs)        self.grid_columnconfigure(0, weight=1)        self.grid_columnconfigure(1, weight=1)        self._config_data_dict = config_data_dict        self._on_new_session_func = on_new_session_func        # TITLE        self._register_frame_title = Label(self, text="Register 2 Park", **style_lbl_title)        self._register_frame_title.grid(row=0, column=0, columnspan=2, **grid_lbl)        # LABELS COLUMN        self._register_apt_number_lbl = Label(self, text="Apt. #", **style_lbl)        self._register_apt_number_lbl.grid(row=1, column=0, **grid_lbl)        self._register_apt_desc_lbl = Label(self, text="Apt. Description", **style_lbl)        self._register_apt_desc_lbl.grid(row=2, column=0, **grid_lbl)        self._register_make_lbl = Label(self, text="Make", **style_lbl)        self._register_make_lbl.grid(row=3, column=0, **grid_lbl)        self._register_model_lbl = Label(self, text="Model", **style_lbl)        self._register_model_lbl.grid(row=4, column=0, **grid_lbl)        self._register_licence_lbl = Label(self, text="License Plate #", **style_lbl)        self._register_licence_lbl.grid(row=5, column=0, **grid_lbl)        self._register_email_lbl = Label(self, text="Email", **style_lbl)        self._register_email_lbl.grid(row=6, column=0, **grid_lbl)        self.extended_stay_btn = CheckbuttonPlus(self, text="Staying Long?", select_func=lambda: self.__show_extended_stay_frame(), deselect_func=lambda: self.__hide_extended_stay_frame(), **style_checkbtn)        self.extended_stay_btn.grid(row=7, column=0, **grid_btn)        # ENTRIES COLUMN        self.register_apt_number_display = Label(self, text="test", **style_lbl)        self.register_apt_number_display.grid(row=1, column=1, **grid_lbl)        self._register_apt_desc_display = Label(self, text=apt_desc, **style_lbl)        self._register_apt_desc_display.grid(row=2, column=1, **grid_lbl)        self._register_make_var = StringVar()        self._register_make_var.trace('w', lambda event, x, y: first_to_upper(self._register_make_var))        self._register_make_entry = Entry(self, textvariable=self._register_make_var, **style_entry)        self._register_make_entry.grid(row=3, column=1, **grid_lbl)        self._register_model_var = StringVar()        self._register_model_var.trace('w', lambda event, x, y: first_to_upper(self._register_model_var))        self._register_model_entry = Entry(self, textvariable=self._register_model_var, **style_entry)        self._register_model_entry.grid(row=4, column=1, **grid_lbl)        self._register_license_number_var = StringVar()        self._register_license_number_var.trace('w', lambda event, x, y: to_upper(self._register_license_number_var))        self._register_licence_entry = Entry(self, textvariable=self._register_license_number_var, **style_entry)        self._register_licence_entry.grid(row=5, column=1, **grid_lbl)        self._register_email_var = StringVar()        self._register_email_entry = Entry(self, textvariable=self._register_email_var, **style_entry)        self._register_email_entry.grid(row=6, column=1, **grid_lbl)        self.register_btn = Button(self, text="Register", command=lambda: self.__handle_register_btn(), **style_btn)        self.register_btn.grid(row=7, column=1, **grid_btn)        # EXTENDED STAY FRAME        self._duration_lbl = Label(self, text="Repeat every\n[ {} ]\nfor x times".format(self.register_frequency_text), height=3, **style_lbl)        self._duration_lbl.grid(row=8, column=0, **grid_lbl)        self._duration_lbl.grid_remove()        self._register_count_entry = EntryPlus(self, **style_entry)        self._register_count_entry.set('2')        self._register_count_entry.grid(row=8, column=1, **grid_entry)        self._register_count_entry.grid_remove()        # SET LABEL VALUES        self.__set_label_values(self._config_data_dict)    def __show_extended_stay_frame(self):        self._duration_lbl.grid()        self._register_count_entry.grid()    def __hide_extended_stay_frame(self):        self._duration_lbl.grid_remove()        self._register_count_entry.grid_remove()    def __set_label_values(self, value_dict):        self.register_apt_number_display['text'] = value_dict[APT_NUM_KEY]    def get_from_entries(self):        make = self._register_make_var.get()        model = self._register_model_var.get()        license_num = self._register_license_number_var.get()        email = self._register_email_var.get()        re_register_count = self._register_count_entry.get()        one_time = not self.extended_stay_btn.get()        reg_dict = {            reg_keys.MAKE: make,            reg_keys.MODEL: model,            reg_keys.LICENSE: license_num,            reg_keys.EMAIL: email,        }        new_session = NewParkingSession('test', reg_dict, datetime.now(), self.register_frequency, re_register_count, one_time)        for entry in [make, model, license_num, email]:            if entry == '':                return False        return new_session    # def get_from_entries(self):    #     make = self._register_make_var.get()    #     model = self._register_model_var.get()    #     license_num = self._register_license_number_var.get()    #     email = self._register_email_var.get()    #    #     re_register_count = self._register_count_entry.get()    #    #     reg_dict = {    #         reg_keys.MAKE: make,    #         reg_keys.MODEL: model,    #         reg_keys.LICENSE: license_num,    #         reg_keys.EMAIL: email,    #     }    #    #     session_dict = {    #         ParkingSession.DURATION: re_register_count,    #         ParkingSession.USER_DICT: reg_dict,    #     }    #    #     for entry in [make, model, license_num, email]:    #         if entry == '':    #             return False    #     return session_dict    def __handle_register_btn(self):        new_session = self.get_from_entries()        # ONLY BEGIN REGISTER IF REGISTER KWARGS PASSED        if new_session is not False:            if self._on_new_session_func is not None:                self._on_new_session_func(new_session)    def insert_user_register_info(self, user):        for entry in [            self._register_make_entry,            self._register_model_entry,            self._register_licence_entry,            self._register_email_entry,        ]:            entry.delete(0, END)        self._register_make_entry.insert(0, user[reg_keys.MAKE])        self._register_model_entry.insert(0, user[reg_keys.MODEL])        self._register_licence_entry.insert(0, user[reg_keys.LICENSE])        self._register_email_entry.insert(0, user[reg_keys.EMAIL])class UserListFrame(Frame):    def __init__(self, root, user_data_list, register_frame, *args, **kwargs):        super().__init__(root, *args, **kwargs)        self.grid_columnconfigure(0, weight=1)        self.grid_rowconfigure(0, weight=0)        self.grid_rowconfigure(1, weight=1)        self._user_data_list = user_data_list        self._gui_user_list_dict = {}  # DICT OF TUPLES FOR THE USER LIST WIDGETS, THE KEY IS USERNAME        self.last_user_index = 0        self._register_frame = register_frame        self.user_list_frame_title = Label(self, text="User List", **style_lbl_title)        self.user_list_frame_title.grid(row=0, column=0, **grid_lbl)        self.user_list_scroll_frame = ScrollFrame(self, hide_scroll_bar=True, **style_frame_primary)        self.user_list_scroll_frame.grid(row=1, column=0, **grid_frame_primary)        self.user_list_scroll_frame.view_port.grid_columnconfigure(0, weight=1)        self.user_list_scroll_frame.view_port.grid_columnconfigure(1, weight=0)        # POPULATE WITH DATA        self.__populate_user_list()    def __populate_user_list(self):        sorted_by_name = sorted(self._user_data_list, key=lambda k: k[USER_NAME_KEY])        for user in sorted_by_name:            self.add_user_to_list(user)    def add_user_to_list(self, user_dict: dict):        self._user_data_list.append(user_dict)        user_name = user_dict[USER_NAME_KEY]        delete_btn_args = style_btn        delete_btn_args['width'] = 3        # CREATE USER WIDGETS        user_name_btn = Button(self.user_list_scroll_frame.view_port, text=user_name, command=lambda name=user_dict[USER_NAME_KEY]: self.__handle_user_clicked(name), **style_btn)        delete_user_btn = Button(self.user_list_scroll_frame.view_port, text="[x]", command=lambda name=user_name: self.__handle_delete_user_clicked(name), **delete_btn_args)        # GRID USER WIDGETS        user_name_btn.grid(row=self.last_user_index, column=0, **grid_btn)        delete_user_btn.grid(row=self.last_user_index, column=1, **grid_btn)        # ADD TO GUI USER DICT        user_row = self.last_user_index        self._gui_user_list_dict[user_name] = (user_row, user_name_btn, delete_user_btn)        # INCREASE LAST USER INDEX        self.last_user_index += 1    def __handle_user_clicked(self, name):        for user in self._user_data_list:            if name == user[USER_NAME_KEY]:                self._register_frame.insert_user_register_info(user)    def __handle_delete_user_clicked(self, name):        deleted_user_row = self._gui_user_list_dict[name][USER_ROW_INDEX]        self._gui_user_list_dict[name][NAME_BTN_INDEX].grid_forget()        self._gui_user_list_dict[name][DELETE_BTN_INDEX].grid_forget()        for gui_user in self._gui_user_list_dict.values():            current_row_index = gui_user[USER_ROW_INDEX]            if current_row_index > deleted_user_row:                user_name_btn = self._gui_user_list_dict[name][NAME_BTN_INDEX]                user_delete_btn = self._gui_user_list_dict[name][DELETE_BTN_INDEX]                # REGRID THE ROW WHERE IT BELONGS                new_row = current_row_index - 1                user_name_btn.grid(row=new_row)                user_delete_btn.grid(row=new_row)                self._gui_user_list_dict[name] = (new_row, user_name_btn, user_delete_btn)        # REMOVE USER FROM GUI USER LIST DICT        self._gui_user_list_dict.pop(name)class ChromedriverFrame(Frame):    def __init__(self, root, *args, **kwargs):        super().__init__(root, *args, **kwargs)        self.grid_columnconfigure(0, weight=1)        self.grid_rowconfigure(0, weight=1)        self.grid_rowconfigure(1, weight=1)        self.chrome_version_lbl = Label(self, text="Chrome Version: {}".format(get_chrome_version()), **style_lbl)        self.chrome_version_lbl.grid(row=0, column=0, **grid_lbl)        self.upgrade_chromedriver_btn = Button(self, text="Upgrade Chromedriver", command=lambda: download_chrome_driver(PATH_CHROMEDRIVER), **style_btn)        self.upgrade_chromedriver_btn.grid(row=1, column=0, **grid_btn)class RegisterUserFrame(Frame):    def __init__(self, root, add_user_callback=None, *args, **kwargs):        super().__init__(root, *args, **kwargs)        self.grid_columnconfigure(0, weight=1)        self.grid_columnconfigure(1, weight=1)        self._add_user_callback = add_user_callback        # TITLE        self.register_user_title_lbl = Label(self, text="Register User", **style_lbl_title)        self.register_user_title_lbl.grid(row=0, column=0, columnspan=2, **grid_lbl)        # LABELS COLUMN        self.register_user_name_lbl = Label(self, text="Name", **style_lbl)        self.register_user_name_lbl.grid(row=1, column=0, **grid_lbl)        self.register_user_make_lbl = Label(self, text="Make", **style_lbl)        self.register_user_make_lbl.grid(row=2, column=0, **grid_lbl)        self.register_user_model_lbl = Label(self, text="Model", **style_lbl)        self.register_user_model_lbl.grid(row=3, column=0, **grid_lbl)        self.register_user_license_lbl = Label(self, text="License Plate", **style_lbl)        self.register_user_license_lbl.grid(row=4, column=0, **grid_lbl)        self.register_user_email_lbl = Label(self, text="Email", **style_lbl)        self.register_user_email_lbl.grid(row=5, column=0, **grid_lbl)        # ENTRIES COLUMN        self.register_user_name_entry = Entry(self, **style_entry)        self.register_user_name_entry.grid(row=1, column=1, **grid_entry)        self.register_user_make_entry = Entry(self, **style_entry)        self.register_user_make_entry.grid(row=2, column=1, **grid_entry)        self.register_user_model_entry = Entry(self, **style_entry)        self.register_user_model_entry.grid(row=3, column=1, **grid_entry)        self.register_user_license_entry = Entry(self, **style_entry)        self.register_user_license_entry.grid(row=4, column=1, **grid_entry)        self.register_user_email_entry = Entry(self, **style_entry)        self.register_user_email_entry.grid(row=5, column=1, **grid_entry)        # CREATE USER BTN        self.register_user_create_user_btn = Button(self, text="Create User", command=lambda: self.__handle_create_user_btn(), **style_btn)        self.register_user_create_user_btn.grid(row=6, column=1, **grid_btn)    def get_from_entries(self):        # GET VALUES FROM ENTRIES        user_name = self.register_user_name_entry.get()        user_make = self.register_user_make_entry.get()        user_model = self.register_user_model_entry.get()        user_license = self.register_user_license_entry.get()        user_email = self.register_user_email_entry.get()        # CREATE USER DICT        user_dict = {            USER_NAME_KEY: user_name,            reg_keys.MAKE: user_make,            reg_keys.MODEL: user_model,            reg_keys.LICENSE: user_license,            reg_keys.EMAIL: user_email,        }        for key, value in user_dict.items():            print(key, value)        return user_dict    def __handle_create_user_btn(self):        if self._add_user_callback is not None:            self._add_user_callback()        self.clear_entries()    def clear_entries(self):        # CLEAR ALL ENTRIES UPON SUCCESS        for entry in [            self.register_user_name_entry,            self.register_user_make_entry,            self.register_user_model_entry,            self.register_user_license_entry,            self.register_user_email_entry,        ]:            entry.delete(0, END)class ActiveSessionFrame(Frame):    def __init__(self, root, on_new_session_func=None, *args, **kwargs):        super().__init__(root, *args, **kwargs)        self.grid_columnconfigure(0, weight=1)        self._on_new_session_func = on_new_session_func        self.title = Label(self, text="Active Sessions List", **style_lbl_title)        self.title.grid(row=0, column=0, **grid_lbl)        # SESSION FRAME        self._session_frame = Frame(self, **style_frame_primary)        self._session_frame.grid(row=1, column=0, **grid_frame_primary)        self._session_frame.grid_columnconfigure(0, weight=1)        self._session_frame.grid_columnconfigure(1, weight=1)        self._session_frame.grid_columnconfigure(2, weight=1)        self._session_frame.grid_columnconfigure(3, weight=1)        self._session_frame.grid_columnconfigure(4, weight=1)        self._session_frame.grid_columnconfigure(5, weight=1)        self._session_frame.grid_columnconfigure(6, weight=1)        # USER NAME        self._make_display = Label(self._session_frame, **style_lbl)        self._make_display.grid(row=0, column=0, **grid_lbl)        # FIRST REGISTER        self._start_time_display = Label(self._session_frame, **style_lbl)        self._start_time_display.grid(row=0, column=1, **grid_lbl)        # NEXT REGISTER        self._frequency_display = Label(self._session_frame, **style_lbl)        self._frequency_display.grid(row=0, column=2, **grid_lbl)        # START COUNT        self._next_time_display = Label(self._session_frame, **style_lbl)        self._next_time_display.grid(row=0, column=3, **grid_lbl)        # REGISTERS LEFT        self._seconds_until_display = Label(self._session_frame, **style_lbl)        self._seconds_until_display.grid(row=0, column=4, **grid_lbl)        # TIME UNTIL        self._remaining_count_display = Label(self._session_frame, **style_lbl)        self._remaining_count_display.grid(row=0, column=5, **grid_lbl)        # CURRENT TIME        self._current_time_display = Label(self._session_frame, **style_lbl)        self._current_time_display.grid(row=0, column=6, **grid_lbl)    def start_new_session(self, new_session: NewParkingSession):        reg_dict = new_session.reg_dict        make = reg_dict[reg_keys.MAKE]        start_time = new_session.start_time        frequency = new_session.frequency        next_time = new_session.next_time        self._make_display['text'] = make        self._start_time_display['text'] = start_time        self._frequency_display['text'] = frequency        self._next_time_display['text'] = next_time        self.session(new_session)    def session(self, new_session: NewParkingSession):        # STOP IF STOP SESSION IS FLAGGED        if new_session.stop_session is True:            return        current_time = datetime.now()        if new_session.count_remaining != 0:            if current_time < new_session.next_time:                self._seconds_until_display['text'] = (new_session.next_time - current_time).total_seconds()                self.after(1000, lambda x=new_session: self.session(x))            else:                print("time went to 0")        # self._remaining_count_display.config(text=str(seconds))        # current_time = datetime.now().strftime("%H:%M:%S")        # self._current_time_display.config(text=str(current_time))        # seconds -= 1        # if seconds >= 0:        #     self._remaining_count_display.after(1000, lambda x=seconds: self.session(x, session_dict))        # else:        #     if self._on_new_session_func is not None:        #         self._on_new_session_func(session_dict)        #     else:        #         print('DONE')        #         for key, value in session_dict.items():        #             print(key, value)class ParkingLoginApp(NavigableTkFrame):    def __init__(self, root):        super().__init__(root)        # JSON DATA MANAGERS        self._user_data_json = JsonManager(JSON_USERS)        self._user_data_list = self._user_data_json.import_data()        self._config_data_json = JsonManager(JSON_CONFIG)        self._config_data_list = self._config_data_json.import_data()        self.__set_config_data()        self.content_frame.config(width=800, height=800)        self.content_frame.grid_propagate(0)        # CONTENT FRAME FRAMES        class ContentFrameRows:            CHROME = 0            REG_2_PARK = 1            USER_LIST = 2        self._content_rows = ContentFrameRows()        self.register_2_park_content_frame = ContentFrame(self.content_frame, "Register2Park", **style_frame_primary)        self.register_2_park_content_frame.grid_columnconfigure(0, weight=1)        self.register_2_park_content_frame.grid_rowconfigure(0, weight=1)        self.register_2_park_content_frame.view_port.grid_columnconfigure(0, weight=1)        self.register_2_park_content_frame.view_port.grid_columnconfigure(1, weight=0)        self.register_2_park_content_frame.view_port.grid_columnconfigure(2, weight=1)        self.register_2_park_content_frame.view_port.grid_rowconfigure(self._content_rows.REG_2_PARK, weight=0)        self.register_2_park_content_frame.view_port.grid_rowconfigure(self._content_rows.USER_LIST, weight=1)        self.register_2_park_content_frame.view_port.grid_rowconfigure(self._content_rows.CHROME, weight=0)        self.register_user_content_frame = ContentFrame(self.content_frame, "Add User", **style_frame_primary)        self.register_user_content_frame.view_port.grid_columnconfigure(0, weight=1)        self.register_user_content_frame.view_port.grid_rowconfigure(0, weight=0)        self.active_sessions_frame = ContentFrame(self.content_frame, "Active Sessions", **style_frame_primary)        self.active_sessions_frame.view_port.grid_columnconfigure(0, weight=1)        self.active_sessions_frame.view_port.grid_rowconfigure(0, weight=1)        # ADD THE CONTENT FRAMES IN THE CORRECT ORDER        self.add_content_frame(0, self.register_2_park_content_frame)        self.add_content_frame(1, self.register_user_content_frame)        self.add_content_frame(2, self.active_sessions_frame)        ################################################################################################################        # CONTENT FRAME: REGISTER 2 PARK        ################################################################################################################        self.register_frame = RegisterFrame(self.register_2_park_content_frame.view_port, self._config_data_list[0], on_new_session_func=self.__handle_register_btn, **style_frame_primary)        self.register_frame.grid(row=self._content_rows.REG_2_PARK, column=1, **grid_frame_primary)        self.user_list_frame = UserListFrame(self.register_2_park_content_frame.view_port, self._user_data_list, self.register_frame, **style_frame_primary)        self.user_list_frame.grid(row=self._content_rows.USER_LIST, column=0, columnspan=3, **grid_frame_primary)        self.chromedriver_frame = ChromedriverFrame(self.register_2_park_content_frame.view_port, **style_frame_primary)        self.chromedriver_frame.grid(row=self._content_rows.CHROME, column=0, columnspan=3, **grid_frame_primary)        ################################################################################################################        # CONTENT FRAME: REGISTER USER        ################################################################################################################        self.register_user_frame = RegisterUserFrame(self.register_user_content_frame.view_port, lambda: self.__on_add_user(), **style_frame_primary)        self.register_user_frame.grid(row=0, column=0, **grid_frame_primary)        ################################################################################################################        # CONTENT FRAME: ACTIVE SESSIONS        ################################################################################################################        self.active_sessions_sub_frame = ActiveSessionFrame(self.active_sessions_frame.view_port, on_new_session_func=self.simple_register, **style_frame_primary)        self.active_sessions_sub_frame.grid(row=0, column=0, **grid_frame_primary)        # STYLE THE NAV BAR BUTTONS        self.config(bg='black')        self.set_nav_btn_style(**style_navbtn)        self.set_pad(20, 20)        # center_on_screen(self)    def __set_config_data(self):        # IMPORT DATA, ONLY 1 DICT PER PROGRAM SO GET FIRST INDEX        try:            self._config_data_dict = self._config_data_list[0]        except IndexError:            self._config_data_dict = {                APT_NUM_KEY: "Not Set"            }        print(self._config_data_dict)    def grid_widgets(self):        return        # SUB FRAMES: REGISTER USER        # CONFIGURE MINSIZE AND COLUMNS        # self.update()        # min_width = self.winfo_width()        # min_height = 0  # self.winfo_height()        # self.minsize(min_width, min_height)    def handle_window_close(self):        # if messagebox.askokcancel("Quit", "Do you want to quit?"):        self.destroy()    def __save_config_data(self, config_data_dict):        self._config_data_dict = config_data_dict        self._config_data_json.export_data([self._config_data_dict])    def __save_user_data(self):        self._user_data_json.export_data(self._user_data_list)    def __on_add_user(self):        user_dict = self.register_user_frame.get_from_entries()        # ADD USER TO LIST        self.user_list_frame.add_user_to_list(user_dict)        self.__save_user_data()    def __handle_register_btn(self, new_session: NewParkingSession):        if new_session.one_time is True:            # RUN THE REGISTER_2_PARK FUNCTION            self.simple_register(new_session.reg_dict)        else:            print(new_session.reg_dict)            self.active_sessions_sub_frame.start_new_session(new_session)            self.show_frame(2)        return    def simple_register(self, reg_dict):        register_return = register_2_park(chromedriver_path=PATH_CHROMEDRIVER, **reg_dict)        if register_return is not True:            self.display_error_message(register_return)    def display_error_message(self, error_list):        showwarning("Register Error", self.get_error_list(error_list) + "\nChromedriver Location: {}".format(os.getcwd()))    @staticmethod    def get_error_list(errors):        output_format = ""        for _ in errors:            output_format += "{}\n"        return output_format.format(*errors)if __name__ == '__main__':    root = Tk()    root.config(bg='black')    root.grid_columnconfigure(0, weight=1)    root.grid_rowconfigure(0, weight=1)    # JSON DATA MANAGERS    user_data_json = JsonManager(JSON_USERS)    user_data_list = user_data_json.import_data()    parking_app = ParkingLoginApp(root)    # parking_app = RegisterFrame(root)    # parking_app = ChromedriverFrame(root)    # register_frame = RegisterFrame(root)    # parking_app = UserListFrame(root, user_data_list, register_frame)    parking_app.grid(row=0, column=0, sticky='nsew')    parking_app.mainloop()